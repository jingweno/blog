---
layout: post
title: Patching with Class Shadowing and Maven
categories: java
---

Before we start, you may speculate about the usefulness of <a href="http://mindprod.com/jgloss/shadow.html">class shadowing</a>.  Class shadowing can be used as a trick to patch or replace behaviors of  classes at runtime, taking advantage of the first-come first-served  algorithm of Java’s class loader. If there are more than one class with  the same fully qualified name in the Java class loader, the first one  that shows up always take precedence over the rest.

This is extremely useful in some cases. For example, in order  to make some out-of-the-box (OOTB) methods extensible without directly  changing the source, or to provide backward-compatibility support, class  shadowing is a good technique to separate the OOTB code and the  customized code. By creating a patch jar against the OOTB jar and  putting it before the OOTB jar on classpath, classes with the same  qualified name are merged at runtime.

Class shadowing is only one way of patching a class. It’s based on  class loader’s runtime class resolution. Another way is to use class  overlay. For example, the Maven <a href="http://maven.apache.org/plugins/maven-war-plugin/examples/war-overlay.html">war  overlays plugin</a> expands the war file and copy them on top of the  host classes.

If you are already familiar with OSGi based technology, <a href="http://wiki.eclipse.org/FAQ_Can_fragments_be_used_to_patch_a_plug-in%3F">patch  fragment</a> is actually taking advantage of the class shadowing  mechanism. This post is not targeting at building OSGi application but  at standard Maven project.

To instruct Java’s class loader to load jars in a specific order, we can make use of the “-cp” option. For example,

[gist]<script src="http://gist.github.com/499731.js?file=class_shadowing.sh"></script>[/gist]

It tells the class loader that patch.jar is loaded before ootb.jar, hence any classes in patch.jar is overriding the ones in ootb.jar. Besides, we can also make use of the Class-Path attribute of the <a href="http://download.oracle.com/docs/cd/E17476_01/javase/1.5.0/docs/guide/jar/jar.html#JAR%20Manifest">jar  manifest</a> to specify the classpath. We will adopt this method in the follow-up example.

Here is an example we are going to build. HelloWorldProxy is a *proxy* artifact that exports its classpath in such an order that classes in  HelloWorldPatch are replacing classes in HelloWorld. HelloWorldTest depends on HelloWorldProxy and doesn’t know which  implementation(HelloWorld or HelloWorldPatch) HelloWorldProxy is  exporting. The dependency graph is as followed:

<a href="http://owenou.com/blog/wp-content/uploads/2010/07/Screen-shot-2010-07-12-at-11.51.58-AM1.png"><img class="aligncenter size-full wp-image-237" title="Screen shot 2010-07-12 at 11.51.58 AM" src="http://owenou.com/blog/wp-content/uploads/2010/07/Screen-shot-2010-07-12-at-11.51.58-AM1.png" alt="" width="447" height="245" /></a>

In the pom.xml of HelloWorldProxy, it has two dependencies and we put  HelloWorldPatch before HelloWorld, since we would like to see classes in  HelloWorldPatch replacing the ones in HelloWorld. As of Maven 2.0.9, the  ordering of dependencies on the classpath is <a href="http://stackoverflow.com/questions/793054/maven-classpath-order-issues">preserved</a>.  The code snippet is as followed:

[gist]<script src="http://gist.github.com/499731.js?file=HelloWorldProxyDependency.xml"></script>[/gist]

We also need to make sure HelloWorldProxy exports the two jars in the  Class-Path attribute of the MANIFEST.MF file with the correct ordering.  The key is to set the <a href="http://maven.apache.org/shared/maven-archiver/examples/classpath.html">addClasspath</a> flag to true in the maven-jar-plugin:

[gist]<script src="http://gist.github.com/499731.js?file=HelloWorldProxyPlugin.xml"></script>[/gist]

Run “mvn package” in HelloWorldProxy and take a look at the generated  MANIFEST.MF:

<a href="http://owenou.com/blog/wp-content/uploads/2010/07/Screen-shot-2010-07-12-at-11.56.55-AM.png"><img class="aligncenter size-full wp-image-238" title="Screen shot 2010-07-12 at 11.56.55 AM" src="http://owenou.com/blog/wp-content/uploads/2010/07/Screen-shot-2010-07-12-at-11.56.55-AM.png" alt="" width="594" height="102" /></a>

Voila! That’s what we expect! HelloWorldPatch takes precedence over  HelloWorld on HelloWorldProxy’s classpath!

Now HelloWorldTest can safely depends on HelloWorldProxy and expects  that HelloWorldProxy will export HelloWorldPatch’s implementations at  runtime:

[gist]<script src="http://gist.github.com/499731.js?file=HelloWorldDependency.xml"></script>[/gist]

The source of this example is available on GitHub <a href="http://github.com/jingweno/patching_with_class_shadowing_and_maven">http://github.com/jingweno/patching_with_class_shadowing_and_maven</a>.  You can also view it directly with CodeFaces <a href="http://codefaces.org/http://github.com/jingweno/patching_with_class_shadowing_and_maven">http://codefaces.org/http://github.com/jingweno/patching_with_class_shadowing_and_maven</a>.